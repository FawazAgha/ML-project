CS310
Data Structures
K. Raven Russell
krusselc@gmu.edu
George Mason University

Today
– Last Lecture
– More Linked Lists
– Today
– Stacks
– Queues

Linked List Variants
– Node Fields
– Reference to next node (“singly”)
– Reference to previous and next node (“doubly”)
– List Fields
– Keep reference to head node
– Keep reference to tail node (optional)
– Big-O changes for some operations without this
– Track the size (optional)
– Big-O changes for some operations without this

Warm-up Big-O for LIST
Implemen
tation
get
set
add
(end)
(start)
(middle)
search
grow?
shrink?
Static
Array List
No
Dynamic
Array List
Singly
Doubly

Linked List Variants Comparison
– Remember: to insert and remove from the middle you first have
to search for the correct position which is O(n)
– Singly linked list add is constant time but remove requires
searching down to node before last to set to null.
– Doubly linked uses more memory, but still O(n)
Implemen
tation
get
set
add
(end)
(start)
(middle)
search
grow?
shrink?
Singly
1, N
Doubly

Which Implementation is Best?
– Array / Static Array - “row” of memory
– can run out of space
– Dynamic Arrays - arrays that can grow
– cost to copy repeatedly (not so bad)
– insert/remove expensive (not good at all - expensive)
– Linked Lists - tiny blocks of memory “linked” together
– no “quick” memory access
– extra memory to represent compared to array
– fewer “expensive” memory moves

List Implementation Summary
– Though arrays are limited in functionality, constants for arrays
are much faster
Implemen
tation
get
set
add
(end)
(start)
(middle)
search
grow?
shrink?
Array
No
Static
Array List
No
Dynamic
Array List
1*
Singly
1,N
Doubly
**
* Amortized analysis
** Hash Tables, will cover later this semester

General Rule in Data Structures
– Arrays are simple
– get/set anything
– add/remove is obvious (need size variable)
– very clear how data is laid out
– Just about every other data structure is less so
– get/set nontrivial
– must preserve some internal structure - control access
– element-by-element access takes work (time)

Questions?
New Material

Stacks and Queues
– Stack
– Data structure that works like a... stack
– e.g. a stack of paper
– Motivating example: call stack
Image Source: http://en.wikipedia.org/wiki/File:Data_stack.svg
void a() {
b();
print(1);
}
void b() {
c();
print(2);
}
void c() {
print(3);
}
… void main(…) {
a();
b();
}

Stacks and Queues
– Queue
– Data structure that works like a... queue
– or a “line” if you aren't British
– Motivating example: printer queue
Image Source: http://en.wikipedia.org/wiki/File:Data_Queue.svg

Whiteboard…
Slides just here for reference!

Stacks White Board
– Push, pop, peek, isEmpty, size
– Arrays and/or Dynamic Arrays
– Typical solution, good constants
– Linked List
– Can use single linked list
– Larger constant, but consistent performance

Queues White Board
– Enqueue, dequeue, peek, isEmpty, size
– Array w/size (or DynamicArray)
+ “Circular Queue”
– Linked List
– Easy implementation with singly linked list+head/tail reference

Big-O?
– Typical to implement Stack using an Array or Dynamic List
(good constraints)
– Typical to implement Queue using Singly Linked List
Implementation
push
pop
peek
isEmpty
size
Dynamic Array
* Amortized
Stack
Queue
Implementation
enqueue
dequeue
peek
isEmpty
size
Dynamic Array

Stacks and Queues Summary
– Typical to implement Stack using an Array or Dynamic List
(good constraints)
– Typical to implement Queue using Singly Linked List
Implementation
push
pop
peek
isEmpty
size
Dynamic Array
1*
* Amortized
Stack
Queue
Implementation
enqueue
dequeue
peek
isEmpty
size
Dynamic Array
1*

Why the Restricted Operations?
– Why? Because good worst cases
– O(1) for all supported operations
– O(n) space
– Simple data structures
– focus on limited operations
– can be made out of primitive data structures (arrays and linked lists)
– Good for representing time-related data
– call stack
– packet queues

Project 2 Coming Friday!
