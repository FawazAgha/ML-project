CS310
Data Structures
K. Raven Russell
krusselc@gmu.edu
George Mason University

Today
â€“ Last Lecture
â€“ Dynamic Array Lists
â€“ Today
â€“ Dynamic Array List Analysis
â€“ Review: Iterators
â€“ (Time Permitting) Side Track: Streams

Questions?

Dynamic â€“ Changes size when
more space is needed
Array â€“ Whatâ€™s under the hood
(vs. â€œlinkedâ€ list)
List â€“ The human idea

Dynamic Array List Analysis

Data Structure Operations Big-O
â€“ Limitations of these structures?
Operation
Implementatio
get set
add
end
begin
middle
search
grow?
List (Static
List  (Dynamic
Yes

Data Structure Operations Big-O
â€“ Limitations of these structures?
Operation
Implementatio
get set
add
end
begin
middle
search
grow?
List (Static
List  (Dynamic
Yes

Data Structure Operations Big-O
â€“ Limitations of these structures?
Operation
Implementatio
get set
add
end
begin
middle
search
grow?
List (Static
List  (Dynamic
n?
Yes

O(1) â†’ O(n) not good...
â€“ We've lost O(1) for adding items to an array
â€“ Would it just be better to allocate huge arrays?
â€“ What's the initial capacity of the array?
â€“ Wait... we are only occasionally expanding the array...

Whiteboard
Letâ€™s Literally Count the Work

Amortized Analysis
â€“ Looks at the time to perform a sequence of operations
averaged over the number of operations: T(n)/n
â€“ Shows that the average cost over time isn't as bad as the worse
case for a single operation
â€“ Not the same as average case analysis!
â€“ Average Case: the expected cost of each operation (probabilistic)
â€“ Amortized: the average cost of each operation in the worst case (no
probability involved!)

Aggregate Method: Dynamic Arrays
â€“ If we always double the array...
â€“ letâ€™s say ci is the cost of the i-th call
â€“ If i-1 is an exact power of 2, we need to expand and ci = i
â€“ Otherwise ci = 1
Each item needs
to be added
at least once.
Each expansion
is 2 times bigger
than the last, and
there are log n
expansions.

â€“ Time to do â€œnâ€ addsâ€¦
â€“ Time to do 1 add?
Aggregate Method: Dynamic Arrays
3ğ‘›ğ‘›
ğ‘›ğ‘›
Time to do
n adds
# of
adds
Time to
do 1 add
{
{
= 3

Whiteboard
Seeing This With $$

Dynamic List Add: Pre-Paying
â€“ At an intuitive level, we can just pretend that every insert
operation costs 3 units of time
â€“ 1 to insert it into the list
â€“ 1 to move it later
â€“ 1 to move an item that was previously moved
â€“ What's three units of time in big-O?
â€“ Yay!

Data Structure Operations Big-O
â€“ Limitations of these structures?
Operation
Implemen
tation
get set
add
end
begin
middle
search
grow?
List (Static
Dynamic
O(1)
Amortized
Yes

Review: Iterators

Iterators
â€“ The bookmark for data structures!
â€“ Give access to all the items in a collection in some unspecified order
â€“ Conceptually the iterator has a position between two elements
â€“ Operations
â€“ Most important: next() and hasNext()
â€“ Optional: previous(), hasPrevious(), add(), remove()
â€“ Finger on the structure demo...

ConcurrentModificationException
â€“ Java doesn't try to coordinate multiple iterators.
â€“ Easy for reading/viewing
â€“ Difficult for modification
â€“ But youâ€™d need to code this if you wanted this to happen on
your own data structuresâ€¦
itr1 = list.iterator();
itr2 = list.iterator();
itr1.remove();
itr2.next(); // Error

Iterators Basics: Dynamic Arrays
What we want:
curr is a new iterator //initialization
while(curr.hasNext()) { //stop condition
value = curr.next(); //get value AND increment
What this replaces:
int curr = 0
while(curr < size) {
value = arr[curr++];
So the iterator needs to do this:
data & initialization?
_________
when should we stop?
_________
how do we get the next object and move over?
_________

Iterators Basics: Dynamic Arrays
What we want:
curr is a new iterator //initialization
while(curr.hasNext()) { //stop condition
value = curr.next(); //get value AND increment
What this replaces:
int curr = 0
while(curr < size) {
value = arr[curr++];
So the iterator needs to do this:
Data Intialization:
curr = 0
hasNext:
curr < size
next:
arr[curr++]

Java Iterators
â€“ Interface Iterable<T>
â€“ java.lang
â€“ Iterator<T> iterator()
â€“ http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html
â€“ Interface Iterator<E>
â€“ java.util
â€“ boolean hasNext()
â€“ E next()
â€“ http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

Nested Classes - Four Types
â€“ Static Class
â€“ Inner Class
â€“ a.k.a. non-static nested class
â€“ Local Class
â€“ special type of inner class
â€“ Anonymous Class
â€“ special type of inner class
ïƒŸToday

Anonymous Class Example
interface Exporter {
public String export();
class MyClass {
public Exporter getExporter() {
return new Exporter() {
public String export() {
return "Export";
}; //<- very important
Review: What is an interface?

Nested Class Rules â€“ Lots of them
â€“ Static classes
â€“ can't access non-static fields & methods of outer class
â€“ Inner classes
â€“ can't be declared without an instance of the outer class
â€“ Local/Anonymous classes
â€“ can only access local variables defined as final
â€“ Lots more, see Java Tutorial:
â€“ http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html

Typical Anonymous Class Style
import java.util.Iterator;
class MyList<T> implements Iterable<T> {
public Iterator<T> iterator() {
return new Iterator<T>() {
public boolean hasNext() { ... }
public T next() { ... }
};

Two Ways to Use an Iterator
public static void main(String[] args) {
MyList<String> list = new MyList<>();
list.add("Alpha");
list.add("Bravo");
list.add("Charlie");
list.add("Delta");
Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
String item = iter.next();
System.out.println(item);
for(String item : list) {
System.out.println(item);

Other Data Structures? Same!
public static void main(String[] args) {
//if dataStruct implements Iterable<String>
//then the following code will work!
//Option 1: Manual Iteration
Iterator<String> iter = dataStruct.iterator();
while(iter.hasNext()) {
String item = iter.next();
System.out.println(item);
//Option 2: Enhanced for-loop
for(String item : dataStruct) {
System.out.println(item);

Why do we need Iterable/Iterator?
â€“ Each data structure is fundamentally different.
â€“ Without Iterable/Iterator, clients would have to develop code
tailored to each data structure in order to accomplish this.
â€“ Using common interface, want to traverse...
â€“ Lists (Dynamic Arrays, Linked Lists, ...)
â€“ Stacks and Queues
â€“ Trees and Graphs
â€“ etc.

Design/Implementation Choices
â€“ Many design choices for ever iterator implementation:
â€“ Where does it point when it's created?
â€“ For add/remove, where are they added/removed?
â€“ remember conceptually the iterator is...
â€“ Can you have multiple iterators?
â€“ What methods do you want to offer? previous?
â€“ Think about this question again when we cover linked listsâ€¦
â€“ Design depends on the data structure!
â€“ documentation should always explain to usersâ€¦

Questions?

Later in the semesterâ€¦

Iterators forâ€¦
â€“ Note: the implementations listed below are what one â€œusuallyâ€ does, it
isnâ€™t the one any only way to do them.
â€“ Dynamic Arrays:
â€“ Linear traversal
store the index of â€œnextâ€
â€“ Linked Lists:
â€“ Linear traversal
store a reference to the node thatâ€™s â€œnextâ€
â€“ Stacks / Queues:
â€“ Top to bottom (often) or front to back
use underlying storage array/dynamic array/linked list
â€“ Priority Queues:
â€“ Priority order (often)
use underlying storage

Iterators forâ€¦
Note: the implementations listed below are what one â€œusuallyâ€ does, it isnâ€™t the one any
only way to do them.
Trees:
Level-order traversal
If tree stored as an array, store index of next
If tree stored as a linked structure, store a queue of node pointers
Pre-order / Post-order / In-order traversal
store a stack of node pointers
Graphs:
Breadth-first traversal
Store a queue
Depth-first traversal
Store a stack
Sets / Maps:
Doesnâ€™t matter, just visit each item once
use underlying structure walk

Time?
Java Streams Explainedâ€¦

TANGENT: Streams
â€“ As a programmer it is important that you understand the
difference between the following types of things:
â€“ Character streams and Byte streams
â€“ Buffered and Unbuffered streams
â€“ This is definitely introduced in CS262
â€“ If you want to be a professional Java developerâ€¦
â€“ You should know when to use: Scanner vs. FileInputStream vs.
FileReader vs. BufferedInputStream vs. BufferedReader vs.
DataInputStream vs ObjectInputStream ...
â€“ This should have also been introduced in 211
â€“ Go here if you donâ€™t know these:
https://docs.oracle.com/javase/tutorial/essential/io/streams.html
