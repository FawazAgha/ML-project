CS310
Data Structures

Wes Masri wmasri@gmu.edu

List: Definition

- A List is a data structure that represents a number of ordered items
- ....A sequence of items

- The same item may occur more than once
- Each occurrence is considered a distinct item

- List is implemented as:
- Array
- Dynamic Array
- Linked List

Operations on a List

- set a value (at some index)
- get a value (at some index)
- append a value (to the end)
- insert a value (at some index)
- remove a value (at some index)
- search for a value (and return the index)

- Cost of operations (worst case scenario + n large)
- set a value (at some index) ==>

- get a value (at some index) ==>

- append a value (to the end) ==>

- insert a value (at some index) ==>

- remove a value (at some index) ==>

- search for a value (and return the index) ==>

- Cost of operations (worst case scenario + n large)
- set a value (at some index) ==>

- get a value (at some index) ==>

- append a value (to the end) ==>

- insert a value (at some index) ==>

- remove a value (at some index) ==>

- search for a value (and return the index) ==>

- Cost of operations (best case scenario + n large)
- set a value (at some index) ==>

- get a value (at some index) ==>

- append a value (to the end) ==>

- insert a value (at some index) ==>

- remove a value (at some index) ==>

- search for a value (and return the index) ==>

- An array has a fixed size (or capacity) - that cannot be changed!!
int [ ] array1 = new int [ 100 ];	// capacity = 100
- It might be difficult to know a priori what array size is appropriate
==> There is a need to expand (or shrink) the array size

- What if we discover that 12 integers are needed as opposed to 10
int [ ] arr = new int[ 10 ];
int [ ] original = arr;	// 1. Save reference to arr
arr = new int [ 12 ];	// 2. Have arr reference more memory
for( int i = 0; i < 10; i++ ) {	// 3. Copy the old data over
arr[ i ] = original[ i ];
original = null;	// 4. Unreference original array... Why?!!

(a) arr points to 10 integers

(b) step1: original points
to the same 10 integers

(c) step2/step3: arr points to 12 integers, the first 10 of which are copied from original

int [ ] arr = new int[ 10 ];
(d)
step4: the 10 integers are ready for garbage collection

int [ ] original = arr;	// step1. Save reference to arr	(creating an array?) arr = new int [ 12 ];	// step2. Have arr reference more memory
for( int i = 0; i < 10; i++ ) {	// step3. Copy the old data over arr[ i ] = original[ i ];
original = null;	// step4. Unreference original array

- Expanding an array is expensive
==> Allocating new Memory
+ Copying Data from old to new
+ Freeing old Memory

- Better to minimize the frequency of expansions
- Expand by one?
- Expand the array by twice its size, from N items to 2N items? Or from N to 1.5N?

How is it done in the Java Library?

ArrayList< > ArrayList.java

public E set(int index, E element) {
rangeCheck(index);

 E oldValue = elementData(index); elementData[index] = element; return oldValue;

@SuppressWarnings("unchecked") E elementData(int index) {
return (E) elementData[index];

private void rangeCheck(int index) { if (index >= size)
throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

public E get(int index) {
rangeCheck(index);
return elementData(index);

@SuppressWarnings("unchecked")
E elementData(int index) {
return (E) elementData[index];

javac -Xlint:unchecked *.java (for details)

An unchecked warning tells a programmer that a cast may cause a program to throw an exception somewhere else. Suppressing the warning with @SuppressWarnings("unchecked") tells the compiler that the programmer believes the code to be safe and won't cause unexpected exceptions.

public boolean add(E element) { // append ensureCapacityInternal(size + 1); // modCount

elementData[size++] = e;
return true;

public void add(int index, E element) { rangeCheckForAdd(index);

ensureCapacityInternal(size + 1); // modCount...

// right shift data by one, starting from index
System.arraycopy(elementData,  index,
elementData, index + 1, size - index);
elementData[index] = element; size++;

arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

Copies an array from the specified source array, beginning at the specified position, to the specified position of the destination array.

public E remove(int index) { rangeCheck(index);

modCount++; // iterators need to know that the underlying collection has changed
E oldValue = elementData(index);

int numMoved = size - index - 1;
if (numMoved > 0) // left shift data by one
System.arraycopy(elementData,index+1,
      elementData,index, numMoved);

// Let the GC do its work!!!!!!! elementData[--size] = null;

return oldValue;

public int indexOf(Object o) {
if (o == null) {
for (int i = 0; i < size; i++) if (elementData[i]==null)
return i;
} else {
for (int i = 0; i < size; i++)
if (o.equals(elementData[i])) return i;
return -1;

private void ensureCapacityInternal(int minCapacity) {
modCount++; // iterators...
// overflow-conscious code
if (minCapacity - elementData.length > 0) grow(minCapacity);

private void grow(int minCapacity) {
// overflow-conscious code
int oldCapacity = elementData.length;
int newCapacity = oldCapacity +
(oldCapacity >> 1); // add half of oldCapacity (double?)
if (newCapacity - minCapacity < 0) // went beyond needed minCapacity?
newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE > 0)// ~Integer.MAX_VALUE
newCapacity = hugeCapacity(minCapacity); // ~Integer.MAX_VALUE

// create array of size newCapacity + copies into it elementData
elementData = Arrays.copyOf(elementData, newCapacity);

Dynamic Arrays

- Java: ArrayLists

- The add() methods need to ensure that the capacity is adequate

Image Source: http://en.wikipedia.org/wiki/File:Dynamic_array.svg

Array vs. DynamicArray

- Cost of operations (worst case scenario)
- set a value (at some index) ==>

- get a value (at some index) ==>

- append a value (to the end) ==>

- insert a value (at some index) ==>

- remove a value (at some index) ==>

- search for a value (and return the index) ==>

Initial Capacity = 1

Case: expand by 1

Assume m append() calls

Capacity = 1	2	3	4	5	6	7	8 ...	.... m

Total Cost for performing all m operations = cost of allocating + freeing + copying

cost of allocating + freeing =	m x constant + m x constant

cost of copying = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + .... + (m-1)
=~ m x (m + 1)/2 =~ m2/2

Total Cost = m x constant + ~m2
Average cost per append() = (m x constant + ~m2)/m	O(m)

Case: expand by doubling size
Initial Capacity = 1
Assume m append() calls

Capacity = 1	2	4	8	16	32	64	128 ...	.... m/8	m/4	m/2	m

Total Cost for performing all m operations =
                      cost of allocating + freeing + copying
cost of allocating + freeing =	m x constant + m x constant cost of copying =
20+21 + 22+ 23+ 24 + 25 +	....	+ 2k = 2k+1 -1 =~ 2k+1 =~ 2 x 2k

1 + 2 + 4 + 8 + 16 + 32 + .... + m/8 + m/4 + m/2 + m =	=~ 2 x m

Total Cost ~= m x constant + m x constant + 2 x m =~ m
Average cost per append() = (~m)/m	O(1)
