CS310 Data Structures

Dynamic Arrays
Summary of Analysis Approaches

– Empirical Analysis

– Run the program with different n

– Reasonable approach if no access to the code

– Can be used to predict performance

– Approximation Analysis

– Eliminates details to simplify model

– e.g. Tilde (~), Big-Oh, Theta, Omega, etc.

– Machine specific and lacks understanding

– Mathematical Analysis

– Independent of machine

– Can make statements concerning bounds

– Can be used to predict performance

– Independent of machine (instructions->cycles->time)

– Very difficult to perform

– Typically cannot make predictions
Two+ Complexities

– Time-complexity

– How much time given a lot of data?

– Bad: if I need to sort 10 items it's fast, but if I need to sort 1000 and takes 3 hours

– Space-complexity

– How much memory given a lot of data?

– Bad: if I need to store 10 items it takes 10B but if need to sort 1000 it takes 10GB

Dynamic Array, aka ArrayList

Dynamic – Changes size based on actual space needed

Array – It’s using a static array under the hood

List – It behaves like a “list” of items
What is a list?

– On a normal paper-and-pencil list I can do the following: – set a value (at some index)
– get a value (at some index) – append a value (to the end)
– add/insert a value (at some index) – remove a value (at some index)
– search for a value (and return the index)

– How do we make an array work like a pencil-and-paper list?
Basic Outline…

– set()

– parameters: int index, Object to put there

– return: ?? – get()
– parameters: int index – return: Object at index
– add/append()

– parameters: Object to add

– add/insert()

– parameters: int index, Object to add

– return: ??

– Other types of add... parameters: Object?

– remove()

– parameters: int index – return: ??
– Other types of remove... parameters: Object?

– search()

– return: ??

Remember to check for edge cases!

– parameters: Object to find

– return: int index found (or -1 for not found)
Let’s write some pseudocode!

//instance variables:

//add-append ___ add(___)

//get
___ get(___)

//set
___ set(___)

Fill in the
codesketch

//add-insert ___ add(___)

//remove
___ remove(___)

//search
___ search(___)

Let’s program it from scratch!

Everyone, please turn on your laptops

Now, let’s see how the Java class ArrayList does the same thing

public E set(int index, E element) {
     rangeCheck(index);

E oldValue = elementData(index); elementData[index] = element;
     return oldValue;

E elementData(int index) {
return (E) elementData[index];

public E get(int index) {
     rangeCheck(index);
     return elementData(index);

E elementData(int index) {
return (E) elementData[index];

public boolean add(E element) { ensureCapacityInternal(size + 1);

elementData[size++] = e; return true;

public void add(int index, E element) { rangeCheckForAdd(index);

ensureCapacityInternal(size + 1);

System.arraycopy(elementData, index, elementData, index + 1,
size - index); elementData[index] = element; size++;

public E remove(int index) { rangeCheck(index);

modCount++;
E oldValue = elementData(index);

int numMoved = size - index - 1; if (numMoved > 0)
System.arraycopy(elementData, index+1, elementData, 	index,
numMoved);
// Let gc do its work elementData[--size] = null;

return oldValue;

public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    return -1;

private void ensureCapacityInternal( int minCapacity) {
modCount++;
// overflow-conscious code
if (minCapacity - elementData.length > 0) grow(minCapacity);

private void grow(int minCapacity) { // overflow-conscious code
int oldCapacity = elementData.length; int newCapacity = oldCapacity +
(oldCapacity >> 1);
if (newCapacity - minCapacity < 0) newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity);

// minCapacity is usually close to size, so // 	this is a win:
elementData = Arrays.copyOf(elementData, newCapacity);

Algorithmic Analysis of
Dynamic Arrays
Big-O

– What is the Big-O of the following operations: – set a value (at some index)
– get a value (at some index) – append a value (to the end)
– insert a value (at some index)

– remove a value (at some index)

– search for a value (and return the index)

– Hint: is adding/removing different from the front/middle/end? – what does this say about the best/worst case?

static arraylist	?

dynamic arraylist	?

?	no

?	Yes

static arraylist	1

dynamic arraylist	?

1

n	no

?	Yes

static arraylist	1

dynamic arraylist	1

1

n	no

n	Yes

static arraylist	1

dynamic arraylist	1

1

n	no

n	Yes

– We've lost O(1) for adding items to an array

– Would it just be better to allocate huge arrays?

– Wait... we are only occasionally expanding the array...
Amortized Analysis

– Looks at the time to perform a sequence of operations averaged over the number of operations: T(n)/n

– Shows that the average cost over time isn't as bad as the worst case for a single operation

– Not the same as average case analysis!

– Average Case: the expected cost of each operation (probabilistic)

– Amortized: the average cost of each operation in the worst case (no probability involved)
Amortized Analysis (practically)

– Start with an array of size 1

– Add items one at a time; expand when needed – Count the operations required
– Calculate the average time it took for each addition

Let’s do that in a spreadsheet...
Amortized Analysis (formally)

– If we always double the array...

– let’s say ci is the cost of the i-th call

– If i-1 is an exact power of 2, we need to expand and ci = i – Otherwise ci = 1

static arraylist	1

dynamic arraylist	1

1

1*

n	no

n	Yes

* Amortized analysis

Questions?
