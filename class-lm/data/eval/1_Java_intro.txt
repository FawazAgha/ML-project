The Java Programming Language:

A Brief Review

A Simple Java Program

// This program prints Welcome to Java!

public class Welcome {
public static void main(String[] args) { System.out.println("Welcome to Java!");

2

Creating, Compiling, and Running Programs

Compiling Java Source Code
The Java compiler (javac.exe) compiles the source program (Welcome.java) into bytecode which is an intermediate language (Welcome.class)

The Java Virtual Machine or JVM (java.exe) interprets the Java bytecode in Welcome.class

4

Data Types: Almost everything is an object
 Eight Primitive Types
 byte, char,
 short, int, long,
 float, double,
 boolean
 Primitive types ranges are bound at design time, not at (language) implementation time (advantage over C)

 Object References
 Everything else

 boolean:	1-bit. May take on the values true and false only.

 byte:	1 signed byte (two's complement). Covers values from -128 to 127.

 short: 2 bytes, signed (two's complement), -32,768 to 32,767

 int: 4 bytes, signed (two's complement). -2,147,483,648 to 2,147,483,647.

 long: 8 bytes signed (two's complement). Ranges from -
9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.

 float: 4 bytes, IEEE format. Covers a range from 1.40129846432481707e-45 to 3.40282346638528860e+38 (positive or negative).

 double: 8 bytes IEEE format. Covers a range from 4.94065645841246544e-324
to 1.79769313486231570e+308 (positive or negative).

 char: 2 bytes, unsigned, Unicode, 0 to 65,535

Wrapper classes to primitive types
 Goal: Treat primitive types as objects.

Class
Constructor
Accessor Method
Byte
public Byte(byte)
public byte byteValue()
Short
public Short(short)
public short shortValue()
Integer
public Integer(int)
public int intValue()
Long
public Long(long)
public long longValue()
Float
public Float(float)
public float floatValue()
Double
public Double(double)
public double doubleValue()
Character
public Character(char)
public char charValue()
Boolean
public Boolean(boolean)
public boolean booleanValue()
 Can you populate a List of Set with the primitive value 5 or 100?

 Java Collections...Generics

Example: Wrapper classes to primitive types
How to convert an int to an Integer object: int val = 10;
Integer intObj = new Integer(val);

How do we convert an Integer to an int?
val = intObj.intValue(); // intValue() is an accessor method.

Some information about Integer:
 Integer(int value) - Constructs a newly allocated Integer object that represents the primitive int argument.
 Integer(String s) - Constructs a newly allocated Integer object that
represents the value represented by the string. If the String object can't be
parsed to be an integer, a NumberFormatException is thrown.

 It is immutable

 Example:
String intStr = "12";
Integer intObj = new Integer(intStr);

A "class" is a user defined data type

What is Encapsulation?

 No direct access to data
 Hiding the data within the class
 Making it available only through the methods
 Each object protects and manages its own data

Why Encapsulation?
Why Data Fields Should Be private?

 Encapsulation separates the implementation details from the interface

 What if the implementation changes... then all clients using it directly will need to be changed... Bad!

 What if you need to change the name and/or type of a given field, or even remove it
completely... then all clients using it directly will need to be changed... Bad!

Class Modifiers

 The public class modifier describes a class that can be instantiated or extended by anything in the same package or by anything that imports the class. Public classes are declared in their own separate file called classname.java, where "classname" is the name of the class.

 If the public class modifier is not used, the class is considered friendly, or package-private. This means that it can be used and instantiated by all classes in the same package.

 The abstract class modifier describes a class that has abstract methods (they have no code).

 The final class modifier describes a class that can have no subclasses.

Variable Modifiers

The visibility of instance variables can be controlled through the use of the following variable modifiers:
 public: Anyone can access public instance variables.

 protected: Only methods of the same package or of its subclasses can access protected instance variables.

 private: Only methods of the same class can access private instance variables.

 If none of the above modifiers are used, the instance variable is considered friendly or package-private. Friendly instance variables can be accessed by any class in the same package.

Variable Modifiers (continued)
 In addition to scope variable modifiers, there are also the following usage modifiers:
 static: The static keyword is used to declare a variable that is associated with the class, not with individual instances of that class. Static variables are used to store "global" information about a class (for example, a static variable could be used to maintain the total number of Person objects created). Static variables exist even if no instance of their class is created.
 final: A final instance variable is one that must be assigned an initial value, and then can never be assigned a new value after that. If it is a base type, then it is a constant. If an object variable it will always refer to the same object (reference) is final, then (even if that object changes its internal state).

Method Modifiers
 public: Anyone can call public methods.
 protected: Only methods of the same package or of subclasses can call a protected method.
 private: Only methods of the same class (not methods of a subclass) can
call a private method.

 The above modifiers may be followed by additional modifiers:
 abstract: A method declared as abstract has no code. For example:
public abstract void setHeight (double newHeight);

 final: This is a method that cannot be overridden by a subclass.
 static: This is a method that is associated with the class itself, and not with a particular instance of the class. Static methods can also be used to change the state of static variables associated with a class (provided these variables are not declared to be final).

Casting

When assigning a double to an int, we may loose precision. This means that the resulting double value will be rounded down. This is not allowed in Java. Needs casting.

But we can assign an int to a double without this worry. No need to casting.

Widening conversions DO NOT need casting Narrowing conversions DO need casting

byte < char < short < int < long < float < double

Casting

 Widening Conversions (non-primitive case):
 A widening conversion occurs when a type T is converted into a "wider"
type U. (U <-- T)
 The following are common cases of widening conversions:
. T and U are class types and U is a superclass of T
. T and U are interface types and U is a superinterface of T
. T is a class that implements interface U.

 Widening conversions are automatically performed to store the result of an expression into a variable, without the need for an explicit cast. Example:
Integer i = new Integer(3);
Number n = i; // widening conversion from Integer to Number

int x;
double y;

x = y; // casting needed? y = x; // casting needed?

Casting: Widening Conversions

 Object References
 LHS of assignment can refer to a wider variety of things than RHS.
 String s = new String("Objection overruled!");
 Object obj;
 obj = s;
String s	Object obj

String object "Objection overruled!"

Casting: Narrowing Conversions
 A narrowing conversion (non-primitive case) occurs when a type T is converted into a "narrower" type S. The following are common cases of narrowing conversions: (S <--T)
. T and S are class types and S is a subclass of T
. T and S are interface types and S is a subinterface of T
. T is an interface implemented by class S.
 A narrowing conversion of reference types requires an explicit cast.
 The correctness of a narrowing conversion may not be verifiable by the compiler. Thus, its validity should be tested by the Java run-time environment during program execution.

Number n = new Integer(2); / / widening conversion from Integer to Number
Integer i = (Integer) n; / / narrowing conversion from Number to Integer

Ariane 5 disaster... (https://en.wikipedia.org/wiki/Ariane_flight_V88)

Casting: Narrowing Conversions
 Object References
 LHS of assignment refers to a narrower variety of things than RHS.
 Requires explicit type cast.
String s = new String("Objection overruled!"); Object obj;
obj = s;

s = new String("Make it so!");
...
s = (String) obj;

String s  Object obj

String s; Object obj;

String object

obj = new String("Objection overruled!"); s = (String) obj; // ?
obj = new Person(); s = obj; // ?
s = (String) obj; // ?

Casting Exceptions

 In Java, we can cast an object reference o of type T into a type S, provided the object o is referring to is actually of type S. If object o is not also of type S, then attempting to cast o to type S will throw an exception called ClassCastException.

We illustrate this rule in the following code fragment:
Number n;
Integer i;
n = new Integer(3);
i = (Integer) n;	/ / This is legal n = new Double(3.1415);
i = (Integer) n;	/ / Compiler error? Runtime error?

Casting

To avoid problems such as this and to avoid peppering our code with try-catch blocks every time we perform a cast, Java provides a way to make sure an object cast will be correct ==> instanceof
that allows us to test whether an object variable is referring to an
object of a certain class:
Number n;
Integer i;
n = new Integer(3);
if (n instanceof Integer) {
i = (Integer) n; / / Compiler error? Runtime error?
n = new Double(3.1415);
if (n instanceof Integer) {
i = (Integer) n; / / This will not be attempted

Casting
The expression (obj instanceof MyClass) is true if:
1. obj is an instance of type MyClass
2. obj is an instance of a subtype of MyClass
3. obj implements MyClass (given that MyClass is an interface)

If obj is null the expression returns false

Another Example

Example: Mechanical Throttle...

public class Throttle {
private int top; // topmost position of lever private int position; // current position of lever public Throttle(int size) { // what if "private"?
top = size; position = 0;

public void shift(int amount)
{
if (position + amount > top) position = top;
else if (position + amount < 0)
position = 0;

else

position += amount;

Reference Variable Assignment

 Code Example 1
Throttle t1; Throttle t2;
t2 = t1;
t2.shift(-5);

 Aliases
 Reference variables that refer to the same object.

Reference Variable Assignment...

 Code Example 2
Throttle t1; Throttle t2;
t2 = new Throttle(100);
t2.shift(25);

 t1 and t2 are not aliases

Equality Test

 Throttle t1;
Throttle t2;
t2 = t1;

 Variables refer to SAME object

 The boolean expression (t1 == t2) is true or false?

Equality Test...

 Throttle t1;
Throttle t2;
 Variables do NOT refer to SAME
object... but their contents are equal

 The boolean expression (t1 == t2) is true or false?

 Always check for equality as follows: (true == t1.equals(t2)). This returns true if t1 and t2 are aliases or have same content (assuming Throttle.equals() is properly implemented)

IMPLEMENT
Throttle.equals()

public boolean equals(Object obj) { // java.lang.Object
return (this == obj);

public boolean equals(Object o) { // Throttle
if (o instanceof Throttle) { Throttle t = (Throttle)o;
return ((top ==t.top) && (position == t.position));

else {

return false;

Intanceof vs getClass( )
The expression (obj instanceof MyClass) is true if:
1) obj is an instance of type MyClass
2) obj is an instance of a subtype of MyClass
3) If obj is null the expression returns false

Should you use instanceof of getClass( )? It depends?
In cases where you want to know if an object implements a given interface or derives from a given class then use instanceof. But if you want to know exactly what type it is, use getClass( ).

Equality

Referential equality: ==
Value equality: equals
 if (v1 == v2) System.out.println("same object");
 if (v1.equals(v2)) System.out.println("same value");
Should (x == y) imply x.equals
Should x.equals(y) imply (x ==

The implementation of equals in Object looks as follows:

public boolean equals(Object obj) { return (this == obj);

If you do not implement Throttle.equals() what would be the behavior in the last 2 cases we discussed?

Inheritance vs. Containment
 Inheritance: "is a" relationship (Student "is a" Person, Circle "is a" Shape)
 Containment: "has a" relationship (Car "has a" Engine)

Generic Types
 We want code that support array of integers, doubles, floats, and longs and display the elements
 One (Nave) solution ==> Overload method "printArray()"

public static void printArray( int[] inputArray ) {
for(int element : inputArray) System.out.printf("%s ", element);

public static void printArray( double[] inputArray ) {
for(double element : inputArray) System.out.printf("%s ", element);

public static void printArray( long[] inputArray ) {
for(long element : inputArray) { System.out.printf("%s ", element);

But can we write a single method that can accept any of the 3 types?

Generic Types
public < E > void printArray( E[] inputArray ) {
for(E element : inputArray) System.out.printf("%s ", element);

public static void main(String args[]) { Integer[] intArray = { 1, 2, 3, 4, 5 };
Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

printArray(intArray); // pass an Integer array

printArray(doubleArray); // pass a Double array

printArray(charArray); // pass a Character array

 A Generic method enables the programmer to specify, with a single method declaration, a set of related methods

 A Generic class enables the programmer to specify, with a single class declaration, a set of related types

 One can write a generic sorting method that could work with Integer arrays, Double arrays, String arrays and so on, to sort the array elements

Generics were Introduced in JDK 1.5

(a) Prior to JDK 1.5	(b) JDK 1.5

Runtime error

(a) Prior to JDK 1.5

Compile error

 Generics allow for catching invalid types at compile time
 A generic class or method permits you to specify allowable types. If you attempt to use the class or method with an incompatible type, a compile error occurs as opposed to a runtime error

 Would you rather catch the error at runtime or compile time?

 ==> would you rather catch the error during a plane flight or long before?

Also... With Generics No Casting is Needed

ArrayList<Double> list = new ArrayList<Double>(); list.add(5.5); // autoboxing to new Double(5.5) list.add(3.0); // autoboxing to new Double(3.0)

Double doubleObject = list.get(0); // No casting is needed since
// the signature is "E get(int)" and E is Double

double d = list.get(1); // the returned Double is unboxed to double

Example: generics/class

public class GenericStack<E> {
private ArrayList<E> list = new ArrayList<>();
public int getSize() {
return list.size();
public E peek() {
return list.get(getSize() - 1);
public void push(E o) { list.add(o);

public E pop() {
E o = list.get(getSize() - 1); list.remove(getSize() - 1); return o;
public boolean isEmpty() { return list.isEmpty();
public String toString() {
return "stack: " + list.toString();
